var util = require('util')
var p2p = require('bitcore-p2p')
var Builder = p2p.Messages.builder
var Inventory = p2p.Inventory
var u = require('bitcoin-util')
var pkg = require('../package.json')
var HeaderStream = require('./headerStream.js')

var commands = Object.keys((new Builder()).commandsMap)

var Peer = module.exports = function (opts) {
  var self = this
  if (this instanceof Peer) {
    p2p.Peer.call(this, opts)
  } else {
    return new Peer(opts)
  }

  if (opts.getTip) this.getTip = opts.getTip

  this.on('connect', function () {
    self.socket.on('error', function (err) {
      self.emit('error', err)
    })
  })
  this.on('ready', function (message) {
    self.connectTime = Date.now()
    if (self.filter) self._sendFilterLoad()
  })
  this.on('version', function (message) {
    self.services = message.services
  })

  // in addition to bitcore-p2p message events, emit as a 'message' event
  commands.forEach(function (command) {
    self.on(command, function (message) {
      self.emit('message', message)
    })
  })

  this.remoteAddress = 'tcp://' + this.host + ':' + this.port
  this.filter = null
}
util.inherits(Peer, p2p.Peer)

Peer.STATUS = p2p.Peer.STATUS

Peer.prototype._sendVersion = function () {
  var message = this.messages.Version({ relay: this.relay })

  message.subversion = '/' + pkg.name + ':' + pkg.version + message.subversion
  if (process.browser) message.subversion += navigator.userAgent + '/'
  else message.subversion += process.title + ':' + process.versions.node + '/'

  if (this.getTip) {
    var tip = this.getTip()
    message.startHeight = tip.height
  }

  this.versionSent = true
  this.sendMessage(message)
}

Peer.prototype.sendMessage = function () {
  if (this.status === Peer.STATUS.DISCONNECTED) return
  var args = Array.prototype.slice.call(arguments, 0)
  p2p.Peer.prototype.sendMessage.apply(this, args)
}

Peer.prototype.getFilter = function () {
  return this.filter
}

Peer.prototype.setFilter = function (filter) {
  if (filter != null && !(filter instanceof p2p.BloomFilter)) {
    throw new Error('Filter must be an instance of bitcore-p2p.BloomFilter')
  }
  this.filter = filter
  if (this.status === Peer.STATUS.READY) {
    if (filter) this._sendFilterLoad()
    else this._sendFilterClear()
  }
}

Peer.prototype.addToFilter = function (data) {
  if (!this.filter) {
    // TODO: create a BloomFilter class that automatically sets its parameters as
    // elements are added
    this.setFilter(p2p.BloomFilter.create(1000, 0.1))
  }
  this.filter.insert(data)
  if (this.status === Peer.STATUS.READY) this._sendFilterAdd(data)
}

Peer.prototype._sendFilterLoad = function () {
  var message = this.messages.FilterLoad(this.filter)
  this.sendMessage(message)
}

Peer.prototype._sendFilterAdd = function (data) {
  var message = this.messages.FilterAdd(data)
  this.sendMessage(message)
}

Peer.prototype._sendFilterClear = function () {
  var message = this.messages.FilterClear()
  this.sendMessage(message)
}

Peer.prototype.createHeaderStream = function (opts) {
  return new HeaderStream(this, opts)
}

// TODO: add a timeout
Peer.prototype.getTransactions = function (txids, cb) {
  var self = this
  var inventory = txids.map(function (txid) {
    return new Inventory({
      type: Inventory.TYPE.TX,
      hash: u.toHash(txid)
    })
  })
  var message = this.messages.GetData(inventory)
  var remaining = txids.length
  var transactions = new Array(txids.length)
  function onTx (res) {
    var txid = u.toHash(res.transaction.id)
    for (var i = 0; i < txids.length; i++) {
      if (txids[i].compare(txid) === 0) break
    }
    if (i === txids.length) return
    transactions[i] = res.transaction
    remaining--
    if (remaining === 0) {
      self.removeListener('tx', onTx)
      cb(null, transactions)
    }
  }
  this.on('tx', onTx)
  this.sendMessage(message)
}
